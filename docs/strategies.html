<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pvp.strategies API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pvp.strategies</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># %%
from functools import partial

import numpy as np
from mesa import Model
from mesa.datacollection import DataCollector
from mesa.space import Grid
from mesa.time import RandomActivation
from numpy.random.mtrand import normal

from .agents import *

# from random import choices



# %%

# TODO: randomly distributed cops doesn&#39;t fully make sense realistically

&#34;&#34;&#34;
Refactor random adder to work with parts of the grid 
Add ability to spawn based on values (aka iterate over grid, pick preallocated values and spawn there)
Add more strategies
&#34;&#34;&#34;


def grid_adder(self, atype):
    &#34;&#34;&#34;
    Refactored adding to the grid. Just increments unique id and adds the object to the grid and schedule
    &#34;&#34;&#34;
    if not atype == None:
        self.unique_id += 1
        self.grid.grid[self.x][self.y] = atype
        self.schedule.add(atype)


def middle_block(self):  # walk around / block in the middle
    x_start = self.width / 3
    y_start = self.height / 3
    x_end = self.width - x_start
    y_end = self.height - y_start
    num_blocks = 0
    for (_, x, y) in self.grid.coord_iter():
        if x_start &lt;= x &lt;= x_end and y_start &lt;= y &lt;= y_end:
            self.x, self.y = x, y
            grid_adder(self, Block(self.unique_id, self, (x, y)))
            num_blocks += 1

    free = (self.numTotalSpaces - num_blocks) * self.grid_density
    citizenProb = (free * self.ratio) / self.numTotalSpaces
    freeProb = (self.numTotalSpaces - free - num_blocks) / self.numTotalSpaces
    copProb = (free - (free * self.ratio)) / self.numTotalSpaces
    blockProb = num_blocks / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
            direction_bias=self.direction_bias,
        )
        self.x, self.y = x, y
        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        agent_dict = {0: None, 1: self.citizen, 2: self.cop}
        if x &lt; x_start or x &gt; x_end or y &lt; y_start or y &gt; y_end:
            rand = choices([0, 1, 2], [freeProb, citizenProb, copProb])
            grid_adder(self, agent_dict[rand[0]])


def random_strategy(self):  # random distribution
    &#34;&#34;&#34;
    Randomly places objects (original)
    &#34;&#34;&#34;
    citizenProb = self.numCitizens / self.numTotalSpaces
    freeProb = (
        self.numTotalSpaces - self.numFreeSpaces - self.barricade
    ) / self.numTotalSpaces
    copProb = self.numCops / self.numTotalSpaces
    blockProb = self.barricade / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=np.random.normal(),
            direction_bias=self.direction_bias,
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
        )

        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        self.block = Block(self.unique_id, self, (x, y))

        self.x, self.y = x, y
        # rand = choices([0, 1, 2, 3], [freeProb, citizenProb, copProb, blockProb])
        rand = np.random.choice(
            [0, 1, 2, 3], p=[freeProb, citizenProb, copProb, blockProb]
        )

        agent_dict = {0: None, 1: self.citizen, 2: self.cop, 3: self.block}
        grid_adder(self, agent_dict[rand])


# %%
def side_strategy(self, side=&#34;left&#34;, agent=&#34;cop&#34;):  # wall of cops
    &#34;&#34;&#34;
    Left/right side : all of one type (eg all cops on the left)
    Rest filled randomly
    Create zero array
    Flatten the array and put the cops
    Reshape back
    &#34;&#34;&#34;
    h, w = self.height, self.width
    self.temp_grid = np.reshape(self.grid.grid, -1)  # flatten

    if side == &#34;left&#34;:  # Set cops
        self.temp_grid[: int(self.numCops)] = 2
    else:
        self.temp_grid[-int(self.numCops) :] = 2

    self.temp_grid = np.reshape(self.temp_grid, (h, w))
    citizenProb = self.numCitizens / self.numTotalSpaces
    freeProb = (
        self.numTotalSpaces - self.numFreeSpaces - self.barricade
    ) / self.numTotalSpaces
    copProb = self.numCops / self.numTotalSpaces
    blockProb = self.barricade / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            direction_bias=self.direction_bias,
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
        )

        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        self.block = Block(self.unique_id, self, (x, y))

        agent_dict = {0: None, 1: self.citizen, 2: self.cop, 3: self.block}

        self.x, self.y = x, y

        if self.temp_grid[y][x] == 2:
            grid_adder(self, agent_dict[2])

        else:
            rand = choices([0, 1, 3], [freeProb, citizenProb, blockProb])
            grid_adder(self, agent_dict[rand[0]])


def streets(self):
    # middle
    y_start = self.height / 6
    y_end = self.height - y_start
    x_mid = self.width / 2
    # sides
    x_end = self.width / 6
    x_start = self.width - x_end

    num_blocks = 0
    for (_, x, y) in self.grid.coord_iter():
        if (
            x &gt;= x_start
            or x &lt;= x_end
            or ((x == x_mid or x == (x_mid + 1)) and y_start &lt;= y &lt;= y_end)
        ):
            self.x, self.y = x, y
            grid_adder(self, Block(self.unique_id, self, (x, y)))
            num_blocks += 1

    free = (self.numTotalSpaces - num_blocks) * self.grid_density
    citizenProb = (free * self.ratio) / self.numTotalSpaces
    freeProb = (self.numTotalSpaces - free - num_blocks) / self.numTotalSpaces
    copProb = (free - (free * self.ratio)) / self.numTotalSpaces
    blockProb = num_blocks / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
            direction_bias=self.direction_bias,
        )
        self.x, self.y = x, y
        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        agent_dict = {0: None, 1: self.citizen, 2: self.cop}
        if x_start &gt; x &gt; x_end and (
            x != x_mid and x != (x_mid + 1) or (y &lt; y_start or y &gt; y_end)
        ):
            rand = choices([0, 1, 2], [freeProb, citizenProb, copProb])
            grid_adder(self, agent_dict[rand[0]])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pvp.strategies.grid_adder"><code class="name flex">
<span>def <span class="ident">grid_adder</span></span>(<span>self, atype)</span>
</code></dt>
<dd>
<div class="desc"><p>Refactored adding to the grid. Just increments unique id and adds the object to the grid and schedule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_adder(self, atype):
    &#34;&#34;&#34;
    Refactored adding to the grid. Just increments unique id and adds the object to the grid and schedule
    &#34;&#34;&#34;
    if not atype == None:
        self.unique_id += 1
        self.grid.grid[self.x][self.y] = atype
        self.schedule.add(atype)</code></pre>
</details>
</dd>
<dt id="pvp.strategies.middle_block"><code class="name flex">
<span>def <span class="ident">middle_block</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def middle_block(self):  # walk around / block in the middle
    x_start = self.width / 3
    y_start = self.height / 3
    x_end = self.width - x_start
    y_end = self.height - y_start
    num_blocks = 0
    for (_, x, y) in self.grid.coord_iter():
        if x_start &lt;= x &lt;= x_end and y_start &lt;= y &lt;= y_end:
            self.x, self.y = x, y
            grid_adder(self, Block(self.unique_id, self, (x, y)))
            num_blocks += 1

    free = (self.numTotalSpaces - num_blocks) * self.grid_density
    citizenProb = (free * self.ratio) / self.numTotalSpaces
    freeProb = (self.numTotalSpaces - free - num_blocks) / self.numTotalSpaces
    copProb = (free - (free * self.ratio)) / self.numTotalSpaces
    blockProb = num_blocks / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
            direction_bias=self.direction_bias,
        )
        self.x, self.y = x, y
        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        agent_dict = {0: None, 1: self.citizen, 2: self.cop}
        if x &lt; x_start or x &gt; x_end or y &lt; y_start or y &gt; y_end:
            rand = choices([0, 1, 2], [freeProb, citizenProb, copProb])
            grid_adder(self, agent_dict[rand[0]])</code></pre>
</details>
</dd>
<dt id="pvp.strategies.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>loc=0.0, scale=1.0, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw random samples from a normal (Gaussian) distribution.</p>
<p>The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).</p>
<p>The normal distributions occurs often in nature.
For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code><a title="pvp.strategies.normal" href="#pvp.strategies.normal">RandomState.normal()</a></code> method of a <code>default_rng()</code>
instance instead; please see the :ref:<code>random-quick-start</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>float</code> or <code>array_like</code> of <code>floats</code></dt>
<dd>Mean ("centre") of the distribution.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code> or <code>array_like</code> of <code>floats</code></dt>
<dd>Standard deviation (spread or "width") of the distribution. Must be
non-negative.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code> or <code>tuple</code> of <code>ints</code>, optional</dt>
<dd>Output shape.
If the given shape is, e.g., <code>(m, n, k)</code>, then
<code>m * n * k</code> samples are drawn.
If size is <code>None</code> (default),
a single value is returned if <code>loc</code> and <code>scale</code> are both scalars.
Otherwise, <code>np.broadcast(loc, scale).size</code> samples are drawn.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>ndarray</code> or <code>scalar</code></dt>
<dd>Drawn samples from the parameterized normal distribution.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>scipy.stats.norm</code></dt>
<dd>probability density function, distribution or cumulative density function, etc.</dd>
<dt><code>Generator.normal</code></dt>
<dd>which should be used for new code.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The probability density for the Gaussian distribution is</p>
<p>[ e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} }, ]
where :math:<code>\mu</code> is the mean and :math:<code>\sigma</code> the standard
deviation. The square of the standard deviation, :math:<code>\sigma^2</code>,
is called the variance.</p>
<p>The function has its peak at the mean, and its "spread" increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:<code>x + \sigma</code> and :math:<code>x - \sigma</code> [2]_).
This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.</p>
<h2 id="references">References</h2>
<p>.. [1] Wikipedia, "Normal distribution",
<a href="https://en.wikipedia.org/wiki/Normal_distribution">https://en.wikipedia.org/wiki/Normal_distribution</a>
.. [2] P. R. Peebles Jr., "Central Limit Theorem" in "Probability,
Random Variables and Random Signal Principles", 4th ed., 2001,
pp. 51, 51, 125.</p>
<h2 id="examples">Examples</h2>
<p>Draw samples from the distribution:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation
&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)
</code></pre>
<p>Verify the mean and the variance:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; abs(mu - np.mean(s))
0.0  # may vary
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1))
0.1  # may vary
</code></pre>
<p>Display the histogram of the samples, along with
the probability density function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)
&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
&gt;&gt;&gt; plt.show()
</code></pre>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
</code></pre></div>
</dd>
<dt id="pvp.strategies.random_strategy"><code class="name flex">
<span>def <span class="ident">random_strategy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly places objects (original)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_strategy(self):  # random distribution
    &#34;&#34;&#34;
    Randomly places objects (original)
    &#34;&#34;&#34;
    citizenProb = self.numCitizens / self.numTotalSpaces
    freeProb = (
        self.numTotalSpaces - self.numFreeSpaces - self.barricade
    ) / self.numTotalSpaces
    copProb = self.numCops / self.numTotalSpaces
    blockProb = self.barricade / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=np.random.normal(),
            direction_bias=self.direction_bias,
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
        )

        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        self.block = Block(self.unique_id, self, (x, y))

        self.x, self.y = x, y
        # rand = choices([0, 1, 2, 3], [freeProb, citizenProb, copProb, blockProb])
        rand = np.random.choice(
            [0, 1, 2, 3], p=[freeProb, citizenProb, copProb, blockProb]
        )

        agent_dict = {0: None, 1: self.citizen, 2: self.cop, 3: self.block}
        grid_adder(self, agent_dict[rand])</code></pre>
</details>
</dd>
<dt id="pvp.strategies.side_strategy"><code class="name flex">
<span>def <span class="ident">side_strategy</span></span>(<span>self, side='left', agent='cop')</span>
</code></dt>
<dd>
<div class="desc"><p>Left/right side : all of one type (eg all cops on the left)
Rest filled randomly
Create zero array
Flatten the array and put the cops
Reshape back</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def side_strategy(self, side=&#34;left&#34;, agent=&#34;cop&#34;):  # wall of cops
    &#34;&#34;&#34;
    Left/right side : all of one type (eg all cops on the left)
    Rest filled randomly
    Create zero array
    Flatten the array and put the cops
    Reshape back
    &#34;&#34;&#34;
    h, w = self.height, self.width
    self.temp_grid = np.reshape(self.grid.grid, -1)  # flatten

    if side == &#34;left&#34;:  # Set cops
        self.temp_grid[: int(self.numCops)] = 2
    else:
        self.temp_grid[-int(self.numCops) :] = 2

    self.temp_grid = np.reshape(self.temp_grid, (h, w))
    citizenProb = self.numCitizens / self.numTotalSpaces
    freeProb = (
        self.numTotalSpaces - self.numFreeSpaces - self.barricade
    ) / self.numTotalSpaces
    copProb = self.numCops / self.numTotalSpaces
    blockProb = self.barricade / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            direction_bias=self.direction_bias,
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
        )

        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        self.block = Block(self.unique_id, self, (x, y))

        agent_dict = {0: None, 1: self.citizen, 2: self.cop, 3: self.block}

        self.x, self.y = x, y

        if self.temp_grid[y][x] == 2:
            grid_adder(self, agent_dict[2])

        else:
            rand = choices([0, 1, 3], [freeProb, citizenProb, blockProb])
            grid_adder(self, agent_dict[rand[0]])</code></pre>
</details>
</dd>
<dt id="pvp.strategies.streets"><code class="name flex">
<span>def <span class="ident">streets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streets(self):
    # middle
    y_start = self.height / 6
    y_end = self.height - y_start
    x_mid = self.width / 2
    # sides
    x_end = self.width / 6
    x_start = self.width - x_end

    num_blocks = 0
    for (_, x, y) in self.grid.coord_iter():
        if (
            x &gt;= x_start
            or x &lt;= x_end
            or ((x == x_mid or x == (x_mid + 1)) and y_start &lt;= y &lt;= y_end)
        ):
            self.x, self.y = x, y
            grid_adder(self, Block(self.unique_id, self, (x, y)))
            num_blocks += 1

    free = (self.numTotalSpaces - num_blocks) * self.grid_density
    citizenProb = (free * self.ratio) / self.numTotalSpaces
    freeProb = (self.numTotalSpaces - free - num_blocks) / self.numTotalSpaces
    copProb = (free - (free * self.ratio)) / self.numTotalSpaces
    blockProb = num_blocks / self.numTotalSpaces

    for (_, x, y) in self.grid.coord_iter():
        self.citizen = Citizen(
            self.unique_id,
            self,
            (x, y),
            hardship=self.random.random(),
            regime_legitimacy=self.legitimacy,
            risk_aversion=self.random.random(),
            threshold=self.active_threshold,
            vision=self.citizen_vision,
            aggression=self.aggression,
            direction_bias=self.direction_bias,
        )
        self.x, self.y = x, y
        self.cop = Cop(self.unique_id, self, (x, y), vision=self.cop_vision)
        agent_dict = {0: None, 1: self.citizen, 2: self.cop}
        if x_start &gt; x &gt; x_end and (
            x != x_mid and x != (x_mid + 1) or (y &lt; y_start or y &gt; y_end)
        ):
            rand = choices([0, 1, 2], [freeProb, citizenProb, copProb])
            grid_adder(self, agent_dict[rand[0]])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pvp" href="index.html">pvp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pvp.strategies.grid_adder" href="#pvp.strategies.grid_adder">grid_adder</a></code></li>
<li><code><a title="pvp.strategies.middle_block" href="#pvp.strategies.middle_block">middle_block</a></code></li>
<li><code><a title="pvp.strategies.normal" href="#pvp.strategies.normal">normal</a></code></li>
<li><code><a title="pvp.strategies.random_strategy" href="#pvp.strategies.random_strategy">random_strategy</a></code></li>
<li><code><a title="pvp.strategies.side_strategy" href="#pvp.strategies.side_strategy">side_strategy</a></code></li>
<li><code><a title="pvp.strategies.streets" href="#pvp.strategies.streets">streets</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>